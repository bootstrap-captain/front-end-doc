# 基本使用

- Facebook开发的，原生的前端框架
- React16为例

## 1. 原生JS

- 操作DOM繁琐，效率低(DOM-API操作UI)
- 需要DOM大量重绘重排
- 没有组件化编码方案(js,css,html)，代码复用率低

## 2. React

- 组件化，声明式编码，提高开发效率及组件复用率
- React Native中可以使用React语法进行移动端开发
- 虚拟DOM+Dom Diffing算法，尽量减少与真实DOM的交互

# 基础语法

## 1. 入门Demo

- 引入的核心库，CDN方式引入，链接直接到网站，然后CTRR+S保存文件到本地

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>

    <!--引入有顺序-->

    <!--1.React核心库-->
    <script src="https://unpkg.com/react@16/umd/react.development.js"></script>

    <!--2. React操作Dom的库-->
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>

    <!--3. babel
           3.1  ES6->ES5 语法
           3.2  React的jsx -> js-->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>

<!--准备好一个容器-->
<div id="erick">

</div>

<!--一定要写text/babel，表示使用react的jsx语法-->
<script type="text/babel">
    /*1. 创建虚拟Dom*/
    const virtualDom = <h1>Hello, React</h1> //不要加单引号，因为不是字符串
    /*2. 渲染虚拟DOM到页面*/
    ReactDOM.render(virtualDom, document.getElementById('erick'));
</script>
</body>
</html>
```

- 浏览器去翻译babel，可能会比较耗时。后序在prod上，会先完成babel的作用，再发布到生产

![image-20240531111025866](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20240531111025866.png)

## 2. jsx/js

- React的语法，支持两种方式来创建虚拟DOM
- 在React中，如果使用原生js来创建虚拟DOM，比较繁琐

### 2.1 js

- 不用babel的依赖

```html
<!--type为"text/javascript"， 创建嵌套标签比较麻烦-->
<script type="text/javascript">
    const virtualDom = React.createElement('h1', {id: 'title'}, React.createElement('span', {}, 'Hello, React'))
    ReactDOM.render(virtualDom, document.getElementById('erick'));
</script>
```

### 2.2 jsx

- 原生js的语法糖，里面的html也可以进行格式化

```html
<script type="text/babel">
    const virtualDom = <h1 id="title"><span>Hello, React</span></h1>
    ReactDOM.render(virtualDom, document.getElementById('erick'));
</script>
```

## 3. 虚拟DOM

- 虚拟DOM，本质是Object类型的对象(一般对象)
- 虚拟DOM比较轻，真实DOM比较重。虚拟DOM是React内部使用，不需真实DOM那么多的属性
- 虚拟DOM最终会被React转换为真实DOM，呈现在页面上

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="https://unpkg.com/react@16/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>

<div id="erick">

</div>


<script type="text/babel">
    const virtualDom = <h1 id="title"><span>Hello, React</span></h1>
    ReactDOM.render(virtualDom, document.getElementById('erick'));
    console.log(virtualDom);
    console.log(virtualDom instanceof Object);
    const realDom = document.getElementById('erick');
    console.log(realDom); // 真实dom
    debugger
</script>
</body>
</html>
```

## 4. JSX语法

- JavaScript XML
- react定义的，一种类似于XML的js扩展语法： js + xml
- 本质是React.createElement语法的语法糖

### 4.1 基本语法

```bash
# jsx
1. 定义虚拟DOM的内容时，不要加引号
2. jsx中要使用js表达式，变量使用要用 {}
       2.1 js表达式： 会产生一个值，可以放在任何需要值的地方
             a，  a+b， say(),   函数本身
       2.2 js语句：
            if(),  for()
            
3. 绑定样式时，指定样式不要用class，要使用className；   为了避免ES6中的class关键字
4. 内联样式，要用style={{key:value}}方式
5. 虚拟DOM，只能有一个根标签
6. 根标签内的标签必须闭合
7. 标签首字母
         7.1 如果是小写开头，则将该标签转换为html中同名元素。若html中无该标签同名元素，则报错
         7.2 如果是大写开头，react就去渲染对应的组件，若组件没定义，则报错
```

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="https://unpkg.com/react@16/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        .title {
            background-color: brown;
        }
    </style>
</head>
<body>

<div id="erick">

</div>

<script type="text/babel">
    const ERICK_ID = 'tiTle';
    const data = 'Hello React'
    // 1. 创建虚拟dom
    const virtualDom = (
        <div>
            <h1 className="title" id={ERICK_ID.toLowerCase()}>
                <span style={{color: 'white', fontSize: '50px'}}>{data.toUpperCase()}</span>
            </h1>

            <h1 className="title" id={ERICK_ID.toUpperCase()}>
                <span style={{color: 'pink', fontSize: '50px'}}>{data.toUpperCase()}</span>
            </h1>

            <input type="text"/>
        </div>
    )

    // 2. 渲染
    ReactDOM.render(virtualDom, document.getElementById('erick'))
</script>
</body>
</html>
```

### 4.2 demo练习

```html
<script type="text/babel">

    const data = ['apple', 'peach', 'lemon'];
    const virtualDom = (
        <ul>
            {data.map((item, index) => {
                return <li key={index}>{item}</li>
            })
            }
        </ul>
    )

    // 2. 渲染
    ReactDOM.render(virtualDom, document.getElementById('erick'))
</script>
```

# 组件

- 模块化：js的模块化，对js的拆分
- 组件：对js，html，css，image，video，font等的进行拆分

## 1. React开发工具

- 在谷歌浏览器中加入

![image-20240531135737923](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20240531135737923.png)

![image-20240531140028704](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20240531140028704.png)

## 2. 组件创建

### 2.1 函数式组件

- 无状态组件

```js
<script type="text/babel">
    /*1. 函数式组件： 必须要有返回值，返回值就是虚拟DOM
    *     1.1 首字母不要用小写，否则会当作html标签渲染
    *     1.2 首字母大写，就会当作组件来渲染*/
    function ErickComponent() {
        return (
            <h2>
                函数定义的组件：适用于简单组件的定义
            </h2>
        )
    }

    /* 2. 渲染组件到页面
    *   2.1 React解析组件标签，找到了ErickComponent组件
    *   2.2 发现是组件是使用函数定义的，调用该函数
    *   2.3 将返回的虚拟DOM转换为真实DOM,随后呈现在页面*/
    ReactDOM.render(<ErickComponent/>,document.getElementById('erick'));

</script>
```

### 2.2 类式组件

- 有状态组件

```js
<script type="text/babel">
    /*1. 类式组件*/
    class ErickComponent extends React.Component {
        /*1.1 render：ErickComponent的原型对象上，供实例使用*/
        render() {
            return (
                <h1>
                    类定义的组件，适用于复杂组件的定义
                </h1>
            )
        }
    }

    /*2. 渲染组件到页面
    *  2.1 React解析组件标签，找到了ErickComponent组件
    *  2.2 发现组件是使用类定义的，随后new出该类的实例，并通过该实例调用到原型上的render方法
    *  2.3 将render返回的虚拟DOM转换为真实DOM,随后呈现在页面上*/
    ReactDOM.render(<ErickComponent/>, document.getElementById('erick'));

</script>
```

## 3. 三大核心

- 适用于类式组件，是组件实例身上的
- react16，只能在类式组件上玩

### 3.1 state

#### 标准方式

```jsx
<script type="text/babel">

    class WeatherComponent extends React.Component {
        constructor(props) {
            super(props);
            /*this指向当前WeatherComponent的属性
            * 修改当前实例组件的state属性*/
            this.state = {
                isHot: true,
                address: '西安'
            }
            /*绑定*/
            this.change = this.changeWeather.bind(this);
        }

        /*具体的方法: onclick的回调，不是实例调用
        * this是undefined*/
        changeWeather() {
            console.log('修改isHot的值', this.state.isHot);
            /*state不可直接更改，*/
            // this.state.isHot = !this.state.isHot; // 修改了，但是没有React响应
            const isHot = this.state.isHot;
            this.setState({isHot: !isHot}) // 替换当前属性，不影响其他属性
        }

        render() {
            /*this就是ErickComponent的组件实例*/
            console.log(this);
            /*解构赋值*/
            const {isHot, address} = this.state;
            return (
                /*React中，对js原生的BOM事件，都进行了驼峰封装: onclick-->onClick*/
                <h1 onClick={this.change}>
                    <div>
                        今天{address}很{isHot ? '炎热' : '凉爽'}
                    </div>

                    <div>
                        明天{this.state.address}很{this.state.isHot ? '炎热' : '凉爽'}
                    </div>
                </h1>
            )
        }
    }

    /*2. 渲染组件*/
    ReactDOM.render(<WeatherComponent/>, document.getElementById('erick'));


</script>
```

#### 精简方式

```jsx
<script type="text/babel">
    class WeatherComponent extends React.Component {
        /*初始化状态*/
        state = {
            isHot: true,
            address: '西安'
        }

        /*功能函数：箭头函数+赋值语句*/
        changeWeather = () => {
            console.log('修改isHot的值', this.state.isHot);
            const isHot = this.state.isHot;
            this.setState({isHot: !isHot});
        }

        render() {
            console.log(this);
            const {isHot, address} = this.state;
            return (
                <h1 onClick={this.changeWeather}>
                    <div>
                        今天{address}很{isHot ? '炎热' : '凉爽'}
                    </div>

                    <div>
                        明天{this.state.address}很{this.state.isHot ? '炎热' : '凉爽'}
                    </div>
                </h1>
            )
        }
    }

    /*2. 渲染组件*/
    ReactDOM.render(<WeatherComponent/>, document.getElementById('erick'));
</script>
```

### 3.2 props

- 组件之间的状态传递

#### 基本使用

```jsx
<script type="text/babel">
    class Person extends React.Component {

        render() {
            return (
                <ul>
                    <li>姓名：{this.props.name}</li>
                    <li>年龄: {this.props.age}</li>
                    <li>地址: {this.props.address}</li>
                </ul>
            )
        }
    }
    
    /*方式一：基本使用*/
    ReactDOM.render(<Person name="shuzhan" age="20" address="beijing"/>, document.getElementById('first'));

    const person = {name: "shuzhan", age: 20, address: "beijing"};
    /*方式二*/
    ReactDOM.render(<Person name={person.name} age={person.age}
                            address={person.address}/>, document.getElementById('second'));

    /*方式三：是上面的语法糖，属性应该对应上*/
    ReactDOM.render(<Person{...person}/>, document.getElementById('third'));
</script>
```

#### props限制

```jsx
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="https://unpkg.com/react@16/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/prop-types@15.6.2/prop-types.js"></script><!--对标签属性的限制-->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

</head>
<body>

<div id="first">
</div>

<div id="second">
</div>

<script type="text/babel">
    class Person extends React.Component {

        render() {
            /*props属性一旦传递进来，就不许修改*/
            this.props.name = "jack";
            return (
                <ul>
                    <li>姓名：{this.props.name}</li>
                    <li>年龄: {this.props.age + 1}</li>
                    <li>地址: {this.props.address}</li>
                </ul>
            )
        }
    }

    /*加属性*/
    Person.propTypes = {
        name: PropTypes.string.required,
        age: PropTypes.number,
    }
    /*默认值*/
    Person.defaultProps = {
        address: 'NewYork'
    }


    ReactDOM.render(<Person name="erick" age={18}/>, document.getElementById('first'));

    const person = {name: "shuzhan", age: 43}
    ReactDOM.render(<Person {...person}/>, document.getElementById('second'));
</script>
</body>
</html>
```

#### 简写方式

```jsx
<script type="text/babel">
    class Person extends React.Component {
        /*加属性*/
        static propTypes = {
            name: PropTypes.string.required,
            age: PropTypes.number,
        };
        /*默认值*/
        static defaultProps = {
            address: 'NewYork'
        };

        render() {
            return (
                <ul>
                    <li>姓名：{this.props.name}</li>
                    <li>年龄: {this.props.age + 1}</li>
                    <li>地址: {this.props.address}</li>
                </ul>
            )
        }
    }
    
    ReactDOM.render(<Person name="erick" age={18}/>, document.getElementById('first'));
    const person = {name: "shuzhan", age: 43}
    ReactDOM.render(<Person {...person}/>, document.getElementById('second'));
</script>
```

#### 函数式组件使用props

```jsx
<script type="text/babel">
    function Person(props) {
        const {name, age, address} = props;
        return (
            <ul>
                <li>姓名：{name}</li>
                <li>年龄：{age}</li>
                <li>地址：{address}</li>
            </ul>
        )
    }

    /*加属性*/
    Person.propTypes = {
        name: PropTypes.string.required,
        age: PropTypes.number,
    }
    /*默认值*/
    Person.defaultProps = {
        address: 'NewYork'
    }
    ReactDOM.render(<Person name="erick" age={18}/>, document.getElementById('first'));
</script>
```

### 3.3 ref

#### 字符串形式

- React已经慢慢不支持了，效率低，不推荐使用

```jsx
<script type="text/babel">
    class Erick extends React.Component {
        showData = () => {
            /*refs属性*/
            const {input1} = this.refs; // 获取到真实DOM的结点
            alert(input1.value);
        }

        showData2 = () => {
            /*refs属性*/
            const {button1} = this.refs; // 获取到真实DOM的结点
            alert(button1.value);
        }


        render() {
            return (
                <div>
                    <input ref="input1" type="text" placeholder="点击提示数据"></input>
                    <button onClick={this.showData}>点击提示数据</button>

                    <br/>
                    <input ref="button1" onBlur={this.showData2} placeholder="失去焦点提示"></input>
                </div>
            )
        }
    }
    
    ReactDOM.render(<Erick />, document.getElementById('first'));
</script>
```

#### 回调函数形式

- 将当前结点，放在当前实例组件的属性上
- 内联形式

```jsx
<script type="text/babel">
    class Erick extends React.Component {
        showData = () => {
            alert(this.input1.value);
        }

        showData2 = () => {
            alert(this.button1.value);
        }


        render() {
            return (
                <div>
                    <input ref={(currentNode) => {
                        this.input1 = currentNode
                    }} type="text" placeholder="点击提示数据"></input>
                    <button onClick={this.showData}>点击提示数据</button>

                    <br/>
                    <input ref={(currentNode) => {
                        this.button1 = currentNode
                    }} onBlur={this.showData2} placeholder="失去焦点提示"></input>
                </div>
            )
        }
    }

    ReactDOM.render(<Erick/>, document.getElementById('first'));
</script>
```

- 类绑定的回调

```jsx
<script type="text/babel">
    class Erick extends React.Component {
        showData = () => {
            alert(this.input1.value);
        }

        showData2 = () => {
            alert(this.button1.value);
        }

        saveInput = (currentNode) => {
            this.input1 = currentNode;
        }

        saveButton = (currentNode) => {
            this.button1 = currentNode;
        }


        render() {
            return (
                <div>
                    <input ref={this.saveInput} type="text" placeholder="点击提示数据"></input>
                    <button onClick={this.showData}>点击提示数据</button>

                    <br/>
                    <input ref={this.saveButton} onBlur={this.showData2} placeholder="失去焦点提示"></input>
                </div>
            )
        }
    }

    ReactDOM.render(<Erick/>, document.getElementById('first'));
</script>
```

#### createRef

- React最推荐的一种

```jsx
<script type="text/babel">
    class Erick extends React.Component {

        /*ref容器： 只能保存一个，后加入的会对之前的进行覆盖*/
        inputRef = React.createRef();
        buttonRef = React.createRef();

        showData = () => {
            alert(this.inputRef.current.value);
        }

        showData2 = () => {
            alert(this.buttonRef.current.value);
        }
        
        render() {
            return (
                <div>
                    <input ref={this.inputRef} type="text" placeholder="点击提示数据"></input>
                    <button onClick={this.showData}>点击提示数据</button>

                    <br/>
                    <input ref={this.buttonRef} onBlur={this.showData2} placeholder="失去焦点提示"></input>
                </div>
            )
        }
    }

    ReactDOM.render(<Erick/>, document.getElementById('first'));
</script>
```

## 4. 受控/非受控组件

### 4.1 非受控组件

- 现用现去

```jsx
<script type="text/babel">
    class Login extends React.Component {

        handleSave = () => {
            event.preventDefault();    // 阻止表单提交
            let username = this.username.value;
            let password = this.password.value;
            alert(username + password)
        }

        render() {
            return (
                <form action="" onSubmit={this.handleSave}>
                    用户名：<input ref={(currentNode) => {
                    this.username = currentNode
                }} type="text" name="username"/><br/>
                    密码: <input ref={(currentNode) => {
                    this.password = currentNode
                }} type="password" name="password"/><br/>
                    <button>登陆</button>
                </form>
            )
        }
    }

    ReactDOM.render(<Login/>, document.getElementById('first'));
</script>
```

### 4.2 受控组件

- 每次改变输入框的值，就将其值放入state中

```jsx
<script type="text/babel">
    class Login extends React.Component {

        handleSave = () => {
            event.preventDefault();    // 阻止表单提交
            alert(this.state.username + this.state.password)
        }

        /*属性初始化*/
        state = {
            username: '',
            password: '',
        }

        saveUsername = (event) => {
            this.setState({username: event.target.value})
        }

        savePassword = (event) => {
            this.setState({password: event.target.value})
        }

        render() {
            return (
                <form action="" onSubmit={this.handleSave}>
                    用户名：<input onChange={this.saveUsername} type="text" name="username"/><br/>
                    密码: <input onChange={this.savePassword} type="password" name="password"/><br/>
                    <button>登陆</button>
                </form>
            )
        }
    }

    ReactDOM.render(<Login/>, document.getElementById('first'));
</script>
```

```jsx
<script type="text/babel">
    class Login extends React.Component {

        /*属性初始化*/
        state = {
            username: '',
            password: '',
        }

        handleSave = () => {
            event.preventDefault();    // 阻止表单提交
            alert(this.state.username + this.state.password)
        }

        saveData = (type, event) => {
            this.setState({[type]: event.target.value})
        }

        render() {
            return (
                <form action="" onSubmit={this.handleSave}>
                    用户名：<input onChange={(event) => {
                    this.saveData('username', event)
                }} type="text" name="username"/><br/>

                    密码: <input onChange={(event) => {
                    this.saveData('password', event)
                }} type="password" name="password"/><br/>

                    <button>登陆</button>
                </form>
            )
        }
    }

    ReactDOM.render(<Login/>, document.getElementById('first'));
</script>
```

# 生命周期

- React组件，从创建到死亡会经历一些特定的阶段
- 包含一系列钩子函数(生命周期回调函数)，会在特定的时刻调用

## React-16

### 1. 挂载及更新

- React中，组件第一次渲染，和后续更新状态后的渲染，都会触发React组件默认的一些回调函数
- 所有的回调函数在React.Component中会有默认实现
- 自定义组件在继承React.Component后，可以对其回调函数进行重写

```bash
# 1. 第一次挂载

 # 1.1 constructor
 - 执行构造器里面的方法
 # 1.2 componentWillMount
 - 挂载前的准备工作
 # 1.3 render
 - 将内容挂载到页面上
 # 1.4 componentDidMount
 - 内容挂载完毕后
 
# 2. setState更新
  # 2.1 shouldComponentUpdate
    - 默认返回true，可以自定义实现
    - 调用setState更新state后，是否需要重新render
  # 2.2 componentWillUpdate
  - 重新render
  # 2.3 render
  # 2.4 componentDidUpdate
  - update完成后执行
  
# 3. forceUpdate
  # 3.1 可以在state不改变的情况下，强制刷新
  # 3.2 render
  # 3.3 componentDidUpdate
  
 
# 4. 卸载
  # 4.1 componentWillUnmount
  - 卸载组件前，执行的动作
  # 4.2 卸载组件
```

![image-20240602102203012](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20240602102203012.png)

```jsx
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="https://unpkg.com/react@16/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

</head>
<body>

<div id="first">

</div>

<script type="text/babel">
    class Erick extends React.Component {
        /*1. 构造器*/
        constructor(props) {
            super(props);
            console.log('constructor')
        }

        state = {
            count: 1
        }

        /*2. 组件将要被render之前*/
        componentWillMount() {
            console.log('componentWillMount')
        }

        /*3. 组件被render*/
        render() {
            console.log("render")
            return (
                <div>
                    <h2> 状态：{this.state.count}</h2>
                    <button onClick={this.changeCount}>更新状态</button>
                    <button onClick={this.force}>强制更新</button>
                    <button onClick={this.death}>卸载组件</button>
                </div>
            )
        }

        /*4. 组件挂载完毕后*/
        componentDidMount() {
            console.log('componentDidMount')
        }

        /*5.组件将要被卸载: 收尾工作，React调用*/
        componentWillUnmount() {
            console.log('componentWillUnmount')
        }

        /*更新*/
        shouldComponentUpdate() {
            console.log('shouldComponentUpdate')
            return true;
        }

        componentWillUpdate() {
            console.log('强制更新');
        }

        changeCount = () => {
            let count = this.state.count;
            this.setState({
                count: count + 1
            })
        }

        /*6. 卸载组件*/
        death = () => {
            ReactDOM.unmountComponentAtNode(document.getElementById('first'));
            console.log('卸载完毕')
        }

        force = () => {
            this.forceUpdate();
        }
    }

    ReactDOM.render(<Erick/>, document.getElementById('first'));
</script>
</body>
</html>
```
