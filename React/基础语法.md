# 安装

- 原生的前端框架，用于构建用户界面(数据渲染成HTML视图)的JavaScript库
- Facebook开发的

```bash
# 原生JS痛点
- 操作DOM繁琐，(DOM-API操作UI):     document.getElementById('app')
- 效率低, 每次操作，都需要进行DOM大量重绘重排
- 原生的JavaScript，只有js有模块化，没有组件化编码方案(js,css,html)，代码复用率低

# React特点
- 虚拟DOM+Dom Diffing算法，尽量减少与真实DOM的交互
- 组件化，声明式编码，提高开发效率及组件复用率
- React Native中可以使用React语法进行移动端开发
```

## 1. CDN引入

- 引入的核心库，CDN方式引入，链接直接到网站，然后CTRL+S保存文件到本地

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>

    <!--引入有顺序-->
    <!--1.React核心库-->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>

    <!--2. React操作Dom的库-->
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

    <!--3. babel
           3.1  ES6->ES5 语法
           3.2  React的jsx -> js-->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>

<!--准备好一个容器-->
<div id="erick">

</div>

<!--一定要写text/babel，表示使用react的jsx语法-->
<script type="text/babel">

    /*1. 获取要渲染的节点*/
    const root = ReactDOM.createRoot(document.getElementById('erick'));

    /*2. 创建虚拟Dom*/
    const virtualDom = (
        /*里面写对应的html标签*/
        <h1>Hello, React</h1>
    ) //不要加单引号，因为不是字符串, () 可以省略

    /*3. 渲染虚拟DOM到页面*/
    root.render(virtualDom);
</script>
</body>
</html>
```

- 浏览器去翻译babel，可能会比较耗时。后面在prod上，会先完成babel的作用，再发布到生产

![image-20240531111025866](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20240531111025866.png)

## 2. 脚手架

- 在实际开发中，是基于React官方提供的脚手架，搭建好基本的环境

### 2.1 构建步骤

```bash
# 1. 全局安装 create-react-app的工具(CDK-CLI)
npm install -g create-react-app

# 2. 进入目录，创建好自己的项目
create-react-app erick-demo
```

### 2.2 项目结构

![image-20240602154808599](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20240602154808599.png)

#### index.html

- SPA：single page application

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <!--%PUBLIC_URL%: 代表public文件夹的路径-->
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico"/>
    <title>Erick React</title>
</head>
<body>
<!--主容器：只会放一个组件-->
<div id="root"></div>
</body>
</html>
```

#### index.js

- 入口文件，将APP组件渲染到页面

```js
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

/*获取页面节点,并转换为虚拟DOM*/
const root = ReactDOM.createRoot(document.getElementById('root'));

/*将组件渲染到目标结点的页面上*/
root.render(
    /*使用React严格语法，比如react过时的api*/
    <React.StrictMode>
        <App/>
    </React.StrictMode>
);
```

#### app.js

- 导出APP组件
- 一般不会在这里直接写组件，而是利用app.js来统一导入其他的组件

```js
import React from "react";

/*一个组件*/
export default class App extends React.Component {
    render() {
        return (
            /*组件的jsx写的带有html标签的内容*/
            <div>
                hello
            </div>)
    }
}
```

### 2.3 开发规范

```bash
# 具体的模块，建在src/component/xxx中
- jsx：React的模块组件代码
- js：js功能代码
- css：样式代码

# 导出的模块，可以在App.js中统一配置
```

![image-20240602164303445](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20240602164303445.png)

#### Citi.jsx

- React的组件

```jsx
import {Component} from "react";
import './citi.css'

export class Citi extends Component {
    render() {
        return (
            <div className="citiTitle">
                我是Citi Bank
            </div>
        )
    }
}
```

#### citi.css

- 组件的具体样式

```css
.citiTitle {
    background-color: aqua;
}
```

#### app.js

- 导入其他的组件

```js
import React from "react";
import {Citi} from "./component/Citi/Citi";

/*/*入口的app.js,里面包含多个不同的组件*/
export default class App extends React.Component {
    render() {
        return (
            <div>
                {/*导入其他组件*/}
                <Citi/>
            </div>)
    }
}
```

# JSX

## 1. JSX/Js

- React的语法，支持两种方式来创建虚拟DOM
- JSX最终也会被翻译为JS
- 下面两个例子在React-16中写的

### 1.1 js

- 不用babel的依赖

```html
<!--type为"text/javascript"， 创建嵌套标签比较麻烦-->
<script type="text/javascript">
    const virtualDom = React.createElement('h1', {id: 'title'}, React.createElement('span', {}, 'Hello, React'))
    ReactDOM.render(virtualDom, document.getElementById('erick'));
</script>
```

### 1.2 jsx

- JavaScript XML: 原生js的语法糖，里面的html也可以进行格式化
- React定义的，一种类似于XML的js扩展语法： js + xml
- 本质是React.createElement语法的语法糖

```html
<script type="text/babel">
    const virtualDom = <h1 id="title"><span>Hello, React</span></h1>
    ReactDOM.render(virtualDom, document.getElementById('erick'));
</script>
```

## 2. 基本语法

- 都是写在组件中，属于虚拟DOM的一部分

```jsx
import {Component} from "react";
import './citi.css'
import {Nike} from "../Nike/Nike";

export default class Citi extends Component {
    render() {
        let name = 'erick';
        return (
            /*1. 定义虚拟DOM时，不要加引号*/
            /* 3. 绑定样式时，不要用class, 要使用className,避免和ES6中的class关键字引发冲突*/
            <div className="citiTitle">
                {/*2. 注释使用方法*/}

                {/* 4. 使用内联样式时，用style={{key:value}}方式*/}
                <div style={{background: "red"}}>hello</div>
                {/* 3. 使用js表达式时，使用{}来获取*/}
                我是{name}
                {/* 5. 虚拟DOM, 必须有一个根标签，且根标签内的标签必须闭合，因此用<div>包裹起来*/}

                {/*6.标签首字母
                       如果是小写开头，比如<div>，则将该标签转换为html中同名元素。若html中无该标签同名元素，则报错
                       如果是大写开头，比如<Nike/>，则就去渲染对应的组件，若组件没定义，则报错*/}
                <Nike/>
            </div>
        )
    }
}
```

## 3. 虚拟DOM

- 虚拟DOM，本质是Object类型的对象(一般对象)
- 虚拟DOM比较轻，真实DOM比较重。虚拟DOM是React内部使用，不需真实DOM那么多的属性
- 虚拟DOM最终会被React转换为真实DOM，呈现在页面上

```js
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

/*获取页面节点，并转换为虚拟DOM*/
const root = ReactDOM.createRoot(document.getElementById('root'));
console.log(`虚拟DOM`, root);
console.log(typeof root);

let realDom = document.getElementById('root');
console.log('真实DOM', realDom);

/*将组件渲染到目标结点的页面上*/
root.render(
    /*使用React严格语法，比如react过时的api*/
    <React.StrictMode>
        <App/>
    </React.StrictMode>
);
```

## 4. DOM Differing 算法

# 组件

- 模块化：js的模块化，对js的拆分
- 组件：对js，html，css，image，video，font等的进行拆分

## 1. React开发工具

- 在谷歌浏览器中加入，后面可以在Component中，查看每个组件的具体的属性，组件树之间的关系

![image-20240531135737923](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20240531135737923.png)

![image-20240531140028704](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20240531140028704.png)

## 2. 组件类型

### 2.1 函数式组件

- React18后，新特性可以使用组件的一些特性，官方比较推荐，代码复用率高

```jsx
/*  渲染组件到页面
   * 1. React解析组件标签，找到了NikeComponent组件
   * 2. 发现是组件是使用函数定义的，调用该函数
   * 3. 将返回的该组件的虚拟DOM转换为真实DOM,随后呈现在页面*/
export function NikeComponent() {
    /*1. 必须要有返回值，返回值就是该组件的虚拟DOM
    * 2. 首字母不要用小写，否则会当作html标签渲染
    *    首字母大写，就会当作组件来渲染*/
    return (
        <div>
            Hi,我是函数式组件
        </div>
    )
}
```

- 箭头函数类型，和函数式组件是一样的，不再细说

```jsx
export const AdidasComponent = () => {
    return (
        <div>
            我是箭头函数组件
        </div>
    )
}
```

### 2.2 类式组件

- React16中，因为一些局限，用的比较多

```js
import {Component} from "react";
import './citi.css'

/* 渲染组件到页面
   * 1. React解析组件标签，找到了Citi组件
   * 2. 发现组件是使用类定义的，随后new出该类的实例，并通过该实例调用到原型上的render方法
   * 3. 将render返回的虚拟DOM转换为真实DOM,随后呈现在页面上*/
export default class Citi extends Component {
    /*1. render：Citi的原型对象上，供实例使用*/
    render() {
        return (
            <div>
                我是类式组件
            </div>
        )
    }
}
```

## 3. state

### 3.1 函数式组件

### 3.2 类式组件

#### 标准方式

```jsx
<script type="text/babel">

    class WeatherComponent extends React.Component {
        constructor(props) {
            super(props);
            /*this指向当前WeatherComponent的属性
            * 修改当前实例组件的state属性*/
            this.state = {
                isHot: true,
                address: '西安'
            }
            /*绑定*/
            this.change = this.changeWeather.bind(this);
        }

        /*具体的方法: onclick的回调，不是实例调用
        * this是undefined*/
        changeWeather() {
            console.log('修改isHot的值', this.state.isHot);
            /*state不可直接更改，*/
            // this.state.isHot = !this.state.isHot; // 修改了，但是没有React响应
            const isHot = this.state.isHot;
            this.setState({isHot: !isHot}) // 替换当前属性，不影响其他属性
        }

        render() {
            /*this就是ErickComponent的组件实例*/
            console.log(this);
            /*解构赋值*/
            const {isHot, address} = this.state;
            return (
                /*React中，对js原生的BOM事件，都进行了驼峰封装: onclick-->onClick*/
                <h1 onClick={this.change}>
                    <div>
                        今天{address}很{isHot ? '炎热' : '凉爽'}
                    </div>

                    <div>
                        明天{this.state.address}很{this.state.isHot ? '炎热' : '凉爽'}
                    </div>
                </h1>
            )
        }
    }

    /*2. 渲染组件*/
    ReactDOM.render(<WeatherComponent/>, document.getElementById('erick'));


</script>
```

#### 精简方式

```jsx
<script type="text/babel">
    class WeatherComponent extends React.Component {
        /*初始化状态*/
        state = {
            isHot: true,
            address: '西安'
        }

        /*功能函数：箭头函数+赋值语句*/
        changeWeather = () => {
            console.log('修改isHot的值', this.state.isHot);
            const isHot = this.state.isHot;
            this.setState({isHot: !isHot});
        }

        render() {
            console.log(this);
            const {isHot, address} = this.state;
            return (
                <h1 onClick={this.changeWeather}>
                    <div>
                        今天{address}很{isHot ? '炎热' : '凉爽'}
                    </div>

                    <div>
                        明天{this.state.address}很{this.state.isHot ? '炎热' : '凉爽'}
                    </div>
                </h1>
            )
        }
    }

    /*2. 渲染组件*/
    ReactDOM.render(<WeatherComponent/>, document.getElementById('erick'));
</script>
```

## 4. props

- 组件之间的状态传递

### 4.1 函数式组件

### 4.2 类式组件

#### 基本使用

```jsx
<script type="text/babel">
    class Person extends React.Component {

        render() {
            return (
                <ul>
                    <li>姓名：{this.props.name}</li>
                    <li>年龄: {this.props.age}</li>
                    <li>地址: {this.props.address}</li>
                </ul>
            )
        }
    }
    
    /*方式一：基本使用*/
    ReactDOM.render(<Person name="shuzhan" age="20" address="beijing"/>, document.getElementById('first'));

    const person = {name: "shuzhan", age: 20, address: "beijing"};
    /*方式二*/
    ReactDOM.render(<Person name={person.name} age={person.age}
                            address={person.address}/>, document.getElementById('second'));

    /*方式三：是上面的语法糖，属性应该对应上*/
    ReactDOM.render(<Person{...person}/>, document.getElementById('third'));
</script>
```

#### props限制

```jsx
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="https://unpkg.com/react@16/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/prop-types@15.6.2/prop-types.js"></script><!--对标签属性的限制-->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

</head>
<body>

<div id="first">
</div>

<div id="second">
</div>

<script type="text/babel">
    class Person extends React.Component {

        render() {
            /*props属性一旦传递进来，就不许修改*/
            this.props.name = "jack";
            return (
                <ul>
                    <li>姓名：{this.props.name}</li>
                    <li>年龄: {this.props.age + 1}</li>
                    <li>地址: {this.props.address}</li>
                </ul>
            )
        }
    }

    /*加属性*/
    Person.propTypes = {
        name: PropTypes.string.required,
        age: PropTypes.number,
    }
    /*默认值*/
    Person.defaultProps = {
        address: 'NewYork'
    }


    ReactDOM.render(<Person name="erick" age={18}/>, document.getElementById('first'));

    const person = {name: "shuzhan", age: 43}
    ReactDOM.render(<Person {...person}/>, document.getElementById('second'));
</script>
</body>
</html>
```

#### 简写方式

```jsx
<script type="text/babel">
    class Person extends React.Component {
        /*加属性*/
        static propTypes = {
            name: PropTypes.string.required,
            age: PropTypes.number,
        };
        /*默认值*/
        static defaultProps = {
            address: 'NewYork'
        };

        render() {
            return (
                <ul>
                    <li>姓名：{this.props.name}</li>
                    <li>年龄: {this.props.age + 1}</li>
                    <li>地址: {this.props.address}</li>
                </ul>
            )
        }
    }
    
    ReactDOM.render(<Person name="erick" age={18}/>, document.getElementById('first'));
    const person = {name: "shuzhan", age: 43}
    ReactDOM.render(<Person {...person}/>, document.getElementById('second'));
</script>
```

#### 函数式组件使用props

```jsx
<script type="text/babel">
    function Person(props) {
        const {name, age, address} = props;
        return (
            <ul>
                <li>姓名：{name}</li>
                <li>年龄：{age}</li>
                <li>地址：{address}</li>
            </ul>
        )
    }

    /*加属性*/
    Person.propTypes = {
        name: PropTypes.string.required,
        age: PropTypes.number,
    }
    /*默认值*/
    Person.defaultProps = {
        address: 'NewYork'
    }
    ReactDOM.render(<Person name="erick" age={18}/>, document.getElementById('first'));
</script>
```

## 5.ref

### 5.1 函数式组件

### 5.2 类式组件

#### 字符串形式

- React已经慢慢不支持了，效率低，不推荐使用

```jsx
<script type="text/babel">
    class Erick extends React.Component {
        showData = () => {
            /*refs属性*/
            const {input1} = this.refs; // 获取到真实DOM的结点
            alert(input1.value);
        }

        showData2 = () => {
            /*refs属性*/
            const {button1} = this.refs; // 获取到真实DOM的结点
            alert(button1.value);
        }


        render() {
            return (
                <div>
                    <input ref="input1" type="text" placeholder="点击提示数据"></input>
                    <button onClick={this.showData}>点击提示数据</button>

                    <br/>
                    <input ref="button1" onBlur={this.showData2} placeholder="失去焦点提示"></input>
                </div>
            )
        }
    }
    
    ReactDOM.render(<Erick />, document.getElementById('first'));
</script>
```

#### 回调函数形式

- 将当前结点，放在当前实例组件的属性上
- 内联形式

```jsx
<script type="text/babel">
    class Erick extends React.Component {
        showData = () => {
            alert(this.input1.value);
        }

        showData2 = () => {
            alert(this.button1.value);
        }


        render() {
            return (
                <div>
                    <input ref={(currentNode) => {
                        this.input1 = currentNode
                    }} type="text" placeholder="点击提示数据"></input>
                    <button onClick={this.showData}>点击提示数据</button>

                    <br/>
                    <input ref={(currentNode) => {
                        this.button1 = currentNode
                    }} onBlur={this.showData2} placeholder="失去焦点提示"></input>
                </div>
            )
        }
    }

    ReactDOM.render(<Erick/>, document.getElementById('first'));
</script>
```

- 类绑定的回调

```jsx
<script type="text/babel">
    class Erick extends React.Component {
        showData = () => {
            alert(this.input1.value);
        }

        showData2 = () => {
            alert(this.button1.value);
        }

        saveInput = (currentNode) => {
            this.input1 = currentNode;
        }

        saveButton = (currentNode) => {
            this.button1 = currentNode;
        }


        render() {
            return (
                <div>
                    <input ref={this.saveInput} type="text" placeholder="点击提示数据"></input>
                    <button onClick={this.showData}>点击提示数据</button>

                    <br/>
                    <input ref={this.saveButton} onBlur={this.showData2} placeholder="失去焦点提示"></input>
                </div>
            )
        }
    }

    ReactDOM.render(<Erick/>, document.getElementById('first'));
</script>
```

#### createRef

- React最推荐的一种

```jsx
<script type="text/babel">
    class Erick extends React.Component {

        /*ref容器： 只能保存一个，后加入的会对之前的进行覆盖*/
        inputRef = React.createRef();
        buttonRef = React.createRef();

        showData = () => {
            alert(this.inputRef.current.value);
        }

        showData2 = () => {
            alert(this.buttonRef.current.value);
        }
        
        render() {
            return (
                <div>
                    <input ref={this.inputRef} type="text" placeholder="点击提示数据"></input>
                    <button onClick={this.showData}>点击提示数据</button>

                    <br/>
                    <input ref={this.buttonRef} onBlur={this.showData2} placeholder="失去焦点提示"></input>
                </div>
            )
        }
    }

    ReactDOM.render(<Erick/>, document.getElementById('first'));
</script>
```

## 6. 受控/非受控组件

### 4.1 非受控组件

- 现用现去

```jsx
<script type="text/babel">
    class Login extends React.Component {

        handleSave = () => {
            event.preventDefault();    // 阻止表单提交
            let username = this.username.value;
            let password = this.password.value;
            alert(username + password)
        }

        render() {
            return (
                <form action="" onSubmit={this.handleSave}>
                    用户名：<input ref={(currentNode) => {
                    this.username = currentNode
                }} type="text" name="username"/><br/>
                    密码: <input ref={(currentNode) => {
                    this.password = currentNode
                }} type="password" name="password"/><br/>
                    <button>登陆</button>
                </form>
            )
        }
    }

    ReactDOM.render(<Login/>, document.getElementById('first'));
</script>
```

### 4.2 受控组件

- 每次改变输入框的值，就将其值放入state中

```jsx
<script type="text/babel">
    class Login extends React.Component {

        handleSave = () => {
            event.preventDefault();    // 阻止表单提交
            alert(this.state.username + this.state.password)
        }

        /*属性初始化*/
        state = {
            username: '',
            password: '',
        }

        saveUsername = (event) => {
            this.setState({username: event.target.value})
        }

        savePassword = (event) => {
            this.setState({password: event.target.value})
        }

        render() {
            return (
                <form action="" onSubmit={this.handleSave}>
                    用户名：<input onChange={this.saveUsername} type="text" name="username"/><br/>
                    密码: <input onChange={this.savePassword} type="password" name="password"/><br/>
                    <button>登陆</button>
                </form>
            )
        }
    }

    ReactDOM.render(<Login/>, document.getElementById('first'));
</script>
```

```jsx
<script type="text/babel">
    class Login extends React.Component {

        /*属性初始化*/
        state = {
            username: '',
            password: '',
        }

        handleSave = () => {
            event.preventDefault();    // 阻止表单提交
            alert(this.state.username + this.state.password)
        }

        saveData = (type, event) => {
            this.setState({[type]: event.target.value})
        }

        render() {
            return (
                <form action="" onSubmit={this.handleSave}>
                    用户名：<input onChange={(event) => {
                    this.saveData('username', event)
                }} type="text" name="username"/><br/>

                    密码: <input onChange={(event) => {
                    this.saveData('password', event)
                }} type="password" name="password"/><br/>

                    <button>登陆</button>
                </form>
            )
        }
    }

    ReactDOM.render(<Login/>, document.getElementById('first'));
</script>
```

# 生命周期

- React组件，从创建到死亡会经历一些特定的阶段
- 包含一系列钩子函数(生命周期回调函数)，会在特定的时刻调用

## React-16

### 1. 挂载及更新

- React中，组件第一次渲染，和后续更新状态后的渲染，都会触发React组件默认的一些回调函数
- 所有的回调函数在React.Component中会有默认实现
- 自定义组件在继承React.Component后，可以对其回调函数进行重写

```bash
# 1. 第一次挂载

 # 1.1 constructor
 - 执行构造器里面的方法
 # 1.2 componentWillMount
 - 挂载前的准备工作
 # 1.3 render
 - 将内容挂载到页面上
 # 1.4 componentDidMount
 - 内容挂载完毕后
 
# 2. setState更新
  # 2.1 shouldComponentUpdate
    - 默认返回true，可以自定义实现
    - 调用setState更新state后，是否需要重新render
  # 2.2 componentWillUpdate
  - 重新render
  # 2.3 render
  # 2.4 componentDidUpdate
  - update完成后执行
  
# 3. forceUpdate
  # 3.1 可以在state不改变的情况下，强制刷新
  # 3.2 render
  # 3.3 componentDidUpdate
  
 
# 4. 卸载
  # 4.1 componentWillUnmount
  - 卸载组件前，执行的动作
  # 4.2 卸载组件
```

![image-20240602102203012](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20240602102203012.png)

```jsx
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="https://unpkg.com/react@16/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

</head>
<body>

<div id="first">

</div>

<script type="text/babel">
    class Erick extends React.Component {
        /*1. 构造器*/
        constructor(props) {
            super(props);
            console.log('constructor')
        }

        state = {
            count: 1
        }

        /*2. 组件将要被render之前*/
        componentWillMount() {
            console.log('componentWillMount')
        }

        /*3. 组件被render*/
        render() {
            console.log("render")
            return (
                <div>
                    <h2> 状态：{this.state.count}</h2>
                    <button onClick={this.changeCount}>更新状态</button>
                    <button onClick={this.force}>强制更新</button>
                    <button onClick={this.death}>卸载组件</button>
                </div>
            )
        }

        /*4. 组件挂载完毕后*/
        componentDidMount() {
            console.log('componentDidMount')
        }

        /*5.组件将要被卸载: 收尾工作，React调用*/
        componentWillUnmount() {
            console.log('componentWillUnmount')
        }

        /*更新*/
        shouldComponentUpdate() {
            console.log('shouldComponentUpdate')
            return true;
        }

        componentWillUpdate() {
            console.log('强制更新');
        }

        changeCount = () => {
            let count = this.state.count;
            this.setState({
                count: count + 1
            })
        }

        /*6. 卸载组件*/
        death = () => {
            ReactDOM.unmountComponentAtNode(document.getElementById('first'));
            console.log('卸载完毕')
        }

        force = () => {
            this.forceUpdate();
        }
    }

    ReactDOM.render(<Erick/>, document.getElementById('first'));
</script>
</body>
</html>
```
